# Design-Pattern-Cpp
Design pattern demo   

## UML类图易混淆知识点
### 类间关系——依赖与关联
依赖关系表现为：某类是其他类内部成员的参数或局部变量或返回值;   
关联关系表现为：某类是其他类的属性。

## 创建型设计模式
### Static Factory(静态工厂模式)
#### 特点  
由静态工厂对子类进行实例化;   
并且判断对哪个子类进行实例化也是静态工厂的职责（该特点会破坏“开放-封闭”原则，因为若想新增子类，将不得不修改静态工厂类的代码）。
#### UML类图
![](static_factory/static_factory.png)
### Factory Method(工厂方法模式)
#### 特点
由工厂类对子类进行实例化;但判断对哪个子类进行实例化是用户的责任，工厂类只负责生产具体的子类实例，符合“开放-封闭”原则。   
（具体来说，若想新增子类，只需让新增该子类的具体工厂类，即新增一个继承自工厂类、与新增子类匹配的具体工厂类，无需修改工厂类代码，符合“开放-封闭”原则。）  
#### UML类图
![](factory/factory.png)

## 行为型设计模式
### Stretegy(策略模式)    
#### 目的   
使得算法（策略）的变化不会影响到该算法的用户。    
#### 与静态工厂的区别
1、静态工厂模式中，工厂无需持有具体产品的引用;   
而策略模式中，使用算法（策略）的上下文（Context）需要持有具体算法类的引用，以调用具体算法来实现目的。   
2、上述内容从UML类图上看，就是静态工厂方法中工厂与抽象产品间为依赖关系，而策略模式中上下文与抽象算法间为聚合关系。 
#### UML类图
![](strategy/strategy.png)    

## 结构型设计模式
### Decorate(装饰模式)    
#### 目的   
使某一对象在运行时可被动态的添加职责。   
#### 与继承的区别
继承也是为对象添加职责，但继承是在编译器完成这一任务的;而装饰模式可将其推迟到运行时。   
#### UML类图
![](decorate/decorate.png)   
### Proxy(代理模式)    
#### 目的   
为其他对象提供一种代理，以代理来控制对该对象的访问。   
#### 最典型的应用——引用计数
例如C++11标准引入的std::shared_ptr。    
#### UML类图
![](proxy/proxy.png) 
